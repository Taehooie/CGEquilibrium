# -*- coding: utf-8 -*-
"""ADMM-Based Integration.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PTQOc7BYCQL0jGj4_EE_pCcI4jWCmsoZ
"""

import jax
import jax.numpy as jnp
import pandas as pd
from jax import grad, jit

from jax import random
key = random.PRNGKey(10)

import scipy
import numpy as np

# Variables to be optimized (initial settings)
c_d = 20.
x_path1 =  79.33806311
x_path2 =  125.1719369

# Initialize Lagrange multipliers
lambda_1 = 0.0
lambda_2 = 0.0
rho_ = 0.01
lambda_list = jnp.array([lambda_1, lambda_2])
rho_list = jnp.array([rho_])

@jit
def obj_func(access_cost, x_paths, lambda_list):

    tot_origin_flow = 205.0 # assumption: travelers are selecting auto-modes
    theta = 1.0
    transit_cost = 23.0

    auto_probs = (jnp.exp(-theta*access_cost[0])/(jnp.exp(-theta*access_cost[0])+jnp.exp(-theta*transit_cost)))

    # Link function parameters
    ttff_1, cap_1 = 20, 4500
    ttff_2, cap_2 = 30, 3000

    # Link travel time function (BPR)
    t_1 = ttff_1*(1 + 0.15*(x_paths[0]/cap_1)**4)
    t_2 = ttff_2*(1 + 0.15*(x_paths[1]/cap_2)**4)

    # Path flow travel time
    t_p1 = t_1
    t_p2 = t_2

    # compute min of travel time
    c_s =  jnp.min(jnp.array([t_p1, t_p2]))

    # Volume
    tot_vol = tot_origin_flow*auto_probs
    path_x = jnp.stack([x_paths[0], x_paths[1]], 0) #prediction

    # # Time
    cost_demand = access_cost[0]
    path_t = jnp.stack([t_p1, t_p2], 0) 

    # Constraints to penalize the costs
    link_condi = access_cost[0] - c_s # integrate demand and supply (c_d - c_s)
    flow_condi = tot_vol - x_paths[0] -  x_paths[1] # flow constraint

    ested_val = [path_x, path_t, c_s, link_condi, flow_condi]
    
    loss = path_x[0]*(path_t[0] - c_s) + path_x[1]*(path_t[0] - c_s) + \
           lambda_list[0]*link_condi + 0.01*link_condi**2 + lambda_list[1]*flow_condi + 0.01*flow_condi**2

    return loss

# set up the shape of the variables
access_cost = jnp.array([c_d])
x_paths  = jnp.array([x_path1, x_path2])
# Optimization to train the demand component
train_demand = scipy.optimize.minimize(obj_func, 
                                         access_cost, 
                                         jac  = jit(jax.grad(obj_func)),
                                         args = (x_paths, lambda_list),
                                         method='BFGS')

# set up the shape of the variables
access_cost = jnp.array(train_demand.x)
x_paths  = jnp.array([x_path1, x_path2])
# Optimization to train the supply component
train_supply = scipy.optimize.minimize(obj_func, 
                                         x_paths, 
                                         jac  = jit(jax.grad(obj_func)),
                                         args = (access_cost, lambda_list),
                                         method='BFGS')

"""TO DO: UPDATE LAGRANGIAN PARAMETERS"""
# Check the primal constraints